!>
................................................................................
.    Copyright (c) 2009-2024 Crater Dog Technologies.  All Rights Reserved.    .
................................................................................
.  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.               .
.                                                                              .
.  This code is free software; you can redistribute it and/or modify it under  .
.  the terms of The MIT License (MIT), as published by the Open Source         .
.  Initiative. (See http://opensource.org/licenses/MIT)                        .
................................................................................
<!

!>
CRATER DOG COLLECTION NOTATION
This document is a formal definition of Crater Dog Collection Notation™
(CDCN) using Crater Dog Syntax Notation™ (CDSN).  A language grammar consists
of a set of token definitions and rule definitions.

The following intrinsic character types are context specific:
 * ANY - Any language specific character.
 * LOWER - Any language specific lower case character.
 * UPPER - Any language specific upper case character.
 * DIGIT - Any language specific digit.
 * ESCAPE - Any environment specific escape sequence.
 * CONTROL - Any environment specific (non-printable) control character.
 * EOL - The environment specific end-of-line character.
 * EOF - The environment specific end-of-file marker (pseudo character).

A predicate may be constrained by any of the following cardinalities:
 * predicate{M} - Exactly M instances of the specified predicate.
 * predicate{M..} - M or more instances of the specified predicate.
 * predicate{M..N} - M to N instances of the specified predicate.
 * predicate? - Zero or one instances of the specified predicate.
 * predicate* - Zero or more instances of the specified predicate.
 * predicate+ - One or more instances of the specified predicate.

An inversion "~" within a definition may only be applied to an intrinsic
character type or a glyph range.
<!

!>
TOKEN DEFINITIONS
The following token definitions are used by the scanner to generate the
stream of tokens that are processed by the parser.  Each token name begins
with an upper case letter.  Unlike with rule definitions, a token definition
cannot specify the name of a rule within its definition but it can specify
the name of other tokens.  Token definitions cannot be recursive and the
scanning of tokens is NOT greedy.  And any spaces within a token definition
are NOT ignored.
<!
Base10: '0'..'9'

Base16: '0'..'9' | 'a'..'f'

Boolean: "false" | "true"

Complex: "(" Float Sign Float "i)"

Context: "array" | "Array" | "Catalog" | "List" | "map" | "Map" | "Queue" | "Set" | "Stack"

Delimiter: "[" | "]" | "(" | ")" | ":" | ","

Exponent: ('e' | 'E') Sign Ordinal

Float: Sign? Scalar Exponent?

Fraction: '.' Base10+

Hexadecimal: "0x" Base16+

Integer: Zero | Sign? Ordinal

Letter: LOWER | UPPER

Nil: "nil"

Ordinal: '1'..'9' '0'..'9'*

Rune: "'" ~CONTROL "'"  ! Any printable character.

Scalar: (Zero | Ordinal) Fraction

Sign: '+' | '-'

String: '"' (ESCAPE | ~CONTROL)* '"'

Unicode: 'x' Base16{2} | 'u' Base16{4} | 'U' Base16{8}

Zero: '0'

!>
RULE DEFINITIONS
The following rules are used by the parser when parsing the stream of tokens
generated by the scanner.  Each rule name begins with a lower case letter.
The rule definitions may specify the names of tokens or other rules and are
matched by the parser in the order listed.  A rule definition may also be
directly or indirectly recursive.  The sequence of factors within in a rule
definition may be separated by spaces which are ignored by the parser.
<!
source: collection EOL* EOF  ! Terminated with an end-of-file marker.

collection: "[" (associations | values) "]" "(" Context ")"

associations:
    association ("," association)*
    (EOL association)+ EOL?
    ":"  ! No associations.

association: key ":" value

key: primitive

value: collection | primitive

primitive: Boolean | Complex | Float | Hexadecimal | Integer | Nil | Rune | String

values:
    value ("," value)*
    (EOL value)+ EOL?
    " "  ! No values.

